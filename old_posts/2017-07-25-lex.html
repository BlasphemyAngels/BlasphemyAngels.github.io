<h2 id="正文">正文</h2>

<p>   <a href="http://www.dabeaz.com/ply/ply.html">PLY</a>是由python实现的编译器构建工具，其中包含<code class="language-plaintext highlighter-rouge">lex</code>和<code class="language-plaintext highlighter-rouge">yacc</code>两个模块。<code class="language-plaintext highlighter-rouge">lex.py</code>模块用来将输入字符通过一系列的正则表达式分解成标记序列，<code class="language-plaintext highlighter-rouge">yacc.py</code>通过一些上下文无关的文法来识别编程语言语法。<code class="language-plaintext highlighter-rouge">yacc.py</code>使用<code class="language-plaintext highlighter-rouge">LR</code>解析法，并使用<code class="language-plaintext highlighter-rouge">LALR(1)</code>算法（默认）或者<code class="language-plaintext highlighter-rouge">SLR</code>算法生成分析表。</p>

<p>   本文主要介绍<code class="language-plaintext highlighter-rouge">lex.py</code>，因为我最近用到它做一些字符串方面的数据处理问题，跟编译没关系，也就没看<code class="language-plaintext highlighter-rouge">yacc</code>。</p>

<!--more-->

<h3 id="安装">安装</h3>

<p>   安装很简单：</p>

<ul>
  <li>pip 安装：<code class="language-plaintext highlighter-rouge">pip install ply</code></li>
  <li>源码：<a href="http://www.dabeaz.com/ply/">PLY main</a>下载完后使用<code class="language-plaintext highlighter-rouge">tar -zxvf</code>解压后可以复制里面的<code class="language-plaintext highlighter-rouge">lex.py</code>出来引用就可以了。</li>
</ul>

<h3 id="简介">简介</h3>

<p>   <code class="language-plaintext highlighter-rouge">lex.py</code>将输入的串解析为一系列自定义的字符串。如输入串是下面：</p>

<p><code class="language-plaintext highlighter-rouge">for i range(1, 10)</code></p>

<p>   <code class="language-plaintext highlighter-rouge">lex</code>将串分解为标记：</p>

<p><code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">range</code>, <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">10</code>, <code class="language-plaintext highlighter-rouge">)</code></p>

<p>   为了更好的区分和使用标记，每类标记取一个类型名字(type):</p>

<p>如：</p>

<p>   <code class="language-plaintext highlighter-rouge">ID</code>, <code class="language-plaintext highlighter-rouge">NUMBER</code>, <code class="language-plaintext highlighter-rouge">LPAREN</code>, <code class="language-plaintext highlighter-rouge">RPAREN</code>, 等</p>

<p>那么原始串就是：</p>

<p>(<code class="language-plaintext highlighter-rouge">'FOR'</code>, <code class="language-plaintext highlighter-rouge">'for'</code>), (<code class="language-plaintext highlighter-rouge">'ID'</code>, <code class="language-plaintext highlighter-rouge">'x'</code>), (<code class="language-plaintext highlighter-rouge">'IN'</code>, <code class="language-plaintext highlighter-rouge">'in'</code>), (<code class="language-plaintext highlighter-rouge">'RANGE'</code>, <code class="language-plaintext highlighter-rouge">'range'</code>), (<code class="language-plaintext highlighter-rouge">'LPAREN'</code>, <code class="language-plaintext highlighter-rouge">'('</code>), (<code class="language-plaintext highlighter-rouge">'NUMBER'</code>, ‘1’), …</p>

<h3 id="用法">用法</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ply.lex</span> <span class="k">as</span> <span class="n">lex</span>

<span class="c1"># List of token names.   This is always required
</span><span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span>
   <span class="s">'NUMBER'</span><span class="p">,</span>
   <span class="s">'PLUS'</span><span class="p">,</span>
   <span class="s">'MINUS'</span><span class="p">,</span>
   <span class="s">'TIMES'</span><span class="p">,</span>
   <span class="s">'DIVIDE'</span><span class="p">,</span>
   <span class="s">'LPAREN'</span><span class="p">,</span>
   <span class="s">'RPAREN'</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Regular expression rules for simple tokens
</span><span class="n">t_PLUS</span>    <span class="o">=</span> <span class="s">r'\+'</span>
<span class="n">t_MINUS</span>   <span class="o">=</span> <span class="s">r'-'</span>
<span class="n">t_TIMES</span>   <span class="o">=</span> <span class="s">r'\*'</span>
<span class="n">t_DIVIDE</span>  <span class="o">=</span> <span class="s">r'/'</span>
<span class="n">t_LPAREN</span>  <span class="o">=</span> <span class="s">r'\('</span>
<span class="n">t_RPAREN</span>  <span class="o">=</span> <span class="s">r'\)'</span>

<span class="c1"># A regular expression rule with some action code
</span><span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\d+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Define a rule so we can track line numbers
</span><span class="k">def</span> <span class="nf">t_newline</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\n+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># A string containing ignored characters (spaces and tabs)
</span><span class="n">t_ignore</span>  <span class="o">=</span> <span class="s">' </span><span class="se">\t</span><span class="s">'</span>

<span class="c1"># Error handling rule
</span><span class="k">def</span> <span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"Illegal character '%s'"</span> <span class="o">%</span> <span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Build the lexer
</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="p">.</span><span class="n">lex</span><span class="p">()</span>
</code></pre></div></div>

<p>   上面的方式定义好了<code class="language-plaintext highlighter-rouge">lex</code>，下面的代码使用它:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Test it out
</span><span class="n">data</span> <span class="o">=</span> <span class="s">'... '</span>

<span class="c1"># Give the lexer some input
</span><span class="n">lexer</span><span class="p">.</span><span class="nb">input</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Tokenize
</span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tok</span><span class="p">:</span> <span class="k">break</span>      <span class="c1"># No more input
</span>    <span class="k">print</span> <span class="n">tok</span>
<span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">lexer</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">tok</span>
    <span class="sb">``</span><span class="err">`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">上面给出了两种迭代方式</span><span class="err">。</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">由</span><span class="sb">`lexer.token()`</span><span class="n">方法返回的标记是LexToken类型的实例</span><span class="err">，</span><span class="n">拥有</span><span class="sb">`tok.type`</span><span class="p">,</span><span class="sb">`tok.value`</span><span class="p">,</span><span class="sb">`tok.lineno`</span><span class="n">和</span><span class="sb">`tok.lexpos`</span><span class="n">属性</span><span class="err">，</span><span class="n">其中</span><span class="sb">`tok.type`</span><span class="n">和</span><span class="sb">`tok.value`</span><span class="n">分别代表标记的类型和值一个</span><span class="sb">`t.type`</span><span class="n">的属性</span><span class="err">（</span><span class="n">字符串表示</span><span class="err">）</span><span class="n">来表示标记的类型名称</span><span class="err">，</span><span class="sb">`t.value`</span><span class="n">是标记值</span><span class="err">（</span><span class="n">匹配的实际的字符串</span><span class="err">），</span><span class="sb">`t.lineno`</span><span class="n">表示当前在源输入串中的作业行</span><span class="err">，</span><span class="sb">`t.lexpos`</span><span class="n">表示标记相对于输入串起始位置的偏移</span>

<span class="c1">#### 标记列表
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">上述代码中声明了一个标记列表</span><span class="err">，</span><span class="n">标记列表可以人为给每种类型标记起个名字</span><span class="err">，</span><span class="n">然后在后面方便使用</span><span class="err">。</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span>
   <span class="s">'NUMBER'</span><span class="p">,</span>
   <span class="s">'PLUS'</span><span class="p">,</span>
   <span class="s">'MINUS'</span><span class="p">,</span>
   <span class="s">'TIMES'</span><span class="p">,</span>
   <span class="s">'DIVIDE'</span><span class="p">,</span>
   <span class="s">'LPAREN'</span><span class="p">,</span>
   <span class="s">'RPAREN'</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>
<h4 id="标记的规则">标记的规则</h4>

<p>   每种标记用一个正则表达式规则来表示，每个规则需要以<code class="language-plaintext highlighter-rouge">t_</code>开头声明，表示该声明是对标记的规则定义。对于简单的标记，可以定义成这样（在Python中使用raw string能比较方便的书写正则表达式）：
<code class="language-plaintext highlighter-rouge">t_PLUS = r'\+'</code></p>

<p>   这里，紧跟在<code class="language-plaintext highlighter-rouge">t_</code>后面的单词，必须跟标记列表中的某个标记名称对应。如果需要执行动作的话，规则可以写成一个方法。例如，下面的规则匹配数字字串，并且将匹配的字符串转化成<code class="language-plaintext highlighter-rouge">Python</code>的整型：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\d+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>
    <span class="sb">``</span><span class="err">`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">如果使用方法的话</span><span class="err">，</span><span class="n">正则表达式写成方法的文档字符串</span><span class="err">。</span><span class="n">方法总是需要接受一个</span><span class="sb">`LexToken`</span><span class="n">实例的参数</span><span class="err">，</span><span class="n">该实例有一些属性</span><span class="err">（</span><span class="n">上面已经介绍</span><span class="err">）。</span><span class="n">方法可以在方法体里面修改这些属性</span><span class="err">。</span><span class="n">记住如果再方法中改变了属性</span><span class="err">，</span><span class="n">那么要返回结果token</span><span class="err">（</span><span class="n">如上面代码中的</span><span class="sb">`return  t`</span><span class="p">)</span><span class="err">，</span><span class="n">否则</span><span class="err">，</span><span class="n">标记将被丢弃</span><span class="err">。</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">在</span><span class="sb">`lex`</span><span class="n">内部</span><span class="err">，</span><span class="sb">`lex`</span><span class="p">.</span><span class="n">py用re模块处理模式匹配</span><span class="err">，</span><span class="n">在构造最终的完整的正则式的时候</span><span class="err">，</span><span class="n">用户提供的规则按照下面的顺序加入</span><span class="err">：</span>

<span class="o">*</span> <span class="n">所有由方法定义的标记规则</span><span class="err">，</span><span class="n">按照他们的出现顺序依次加入</span>
<span class="o">*</span> <span class="n">由字符串变量定义的标记规则按照其正则式长度倒序后</span><span class="err">，</span><span class="n">依次加入</span><span class="err">（</span><span class="n">长的先入</span><span class="err">）</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">顺序的约定对于精确匹配是必要的</span><span class="err">。</span><span class="n">比如</span><span class="err">，</span><span class="n">如果你想区分</span><span class="sb">`=`</span><span class="n">和</span><span class="sb">`==`</span><span class="err">，</span><span class="n">你需要确保</span><span class="sb">`==`</span><span class="n">优先检查</span><span class="err">。</span><span class="n">如果用字符串来定义这样的表达式的话</span><span class="err">，</span><span class="n">通过将较长的正则式先加入</span><span class="err">，</span><span class="n">可以帮助解决这个问题</span><span class="err">。</span><span class="n">用方法定义标记</span><span class="err">，</span><span class="n">可以显示地控制哪个规则优先检查</span><span class="err">。</span>

<span class="c1">#### 标记的值
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">标记被</span><span class="sb">`lex`</span><span class="n">返回后</span><span class="err">，</span><span class="n">它们的值被保存在</span><span class="sb">`value`</span><span class="n">属性中</span><span class="err">。</span><span class="n">正常情况下</span><span class="err">，</span><span class="sb">`value`</span><span class="n">是匹配的实际文本</span><span class="err">。</span><span class="n">事实上</span><span class="err">，</span><span class="sb">`value`</span><span class="n">可以被赋为任何</span><span class="sb">`Python`</span><span class="n">支持的类型</span><span class="err">。</span><span class="n">例如</span><span class="err">，</span><span class="n">当扫描到标识符的时候</span><span class="err">，</span><span class="n">你可能不仅需要返回标识符的名字</span><span class="err">，</span><span class="n">还需要返回其在符号表中的位置</span><span class="err">，</span><span class="n">可以像下面这样写</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="k">def</span> <span class="nf">t_ID</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="p">...</span>
    <span class="c1"># Look up symbol table information and return a tuple
</span>    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">symbol_lookup</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">t</span>
    <span class="sb">``</span><span class="err">`</span>
<span class="c1">#### 丢弃标记
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">想丢弃像注释之类的标记</span><span class="err">，</span><span class="n">只要不返回</span><span class="sb">`value`</span><span class="n">就行了</span><span class="err">，</span><span class="n">像这样</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="k">def</span> <span class="nf">t_COMMENT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\#.*'</span>
    <span class="k">pass</span>
    <span class="c1"># No return value. Token discarded
</span>    <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">为标记声明添加</span><span class="sb">`ignore_`</span><span class="n">前缀同样可以达到目的</span><span class="err">：</span>

<span class="sb">`t_ignore_COMMENT = r'\#.*'`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">如果有多种文本需要丢弃</span><span class="err">，</span><span class="n">建议使用方法来定义规则</span><span class="err">，</span><span class="n">因为方法能够提供更精确的匹配优先级控制</span><span class="err">（</span><span class="n">方法根据出现的顺序</span><span class="err">，</span><span class="n">而字符串的正则表达式依据正则表达式的长度</span><span class="err">）</span>

<span class="c1">#### 行号和位置信息
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">默认情况下</span><span class="err">，</span><span class="sb">`lex.py`</span><span class="n">是不提供行号的</span><span class="err">。</span><span class="n">因为</span><span class="sb">`lex.py`</span><span class="n">根本不知道何为</span><span class="err">”</span><span class="n">行</span><span class="err">”</span><span class="n">的概念</span><span class="err">（</span><span class="n">换行符本身也作为文本的一部分</span><span class="err">）。</span><span class="n">不过</span><span class="err">，</span><span class="n">可以通过写一个特殊的规则来记录行号</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="k">def</span> <span class="nf">t_newline</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\n+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
    <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">在这个规则中</span><span class="err">，</span><span class="n">当前</span><span class="sb">`lexer`</span><span class="n">对象</span><span class="sb">`t.lexer`</span><span class="n">的</span><span class="sb">`lineno`</span><span class="n">属性被修改了</span><span class="err">，</span><span class="n">而且空行被简单的丢弃了</span><span class="err">，</span><span class="n">因为没有任何的返回</span><span class="err">。</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="sb">`lex.py`</span><span class="n">也不自动做列跟踪</span><span class="err">。</span><span class="n">但是</span><span class="err">，</span><span class="n">位置信息被记录在了每个标记对象的</span><span class="sb">`lexpos`</span><span class="n">属性中</span><span class="err">，</span><span class="n">这样</span><span class="err">，</span><span class="n">就有可能来计算列信息了</span><span class="err">。</span><span class="n">例如</span><span class="err">：</span><span class="n">每当遇到新行的时候就重置列值</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="c1"># Compute column.
#     input is the input text string
#     token is a token instance
</span><span class="k">def</span> <span class="nf">find_column</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">token</span><span class="p">):</span>
    <span class="n">last_cr</span> <span class="o">=</span> <span class="nb">input</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">token</span><span class="p">.</span><span class="n">lexpos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_cr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">last_cr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">column</span> <span class="o">=</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">lexpos</span> <span class="o">-</span> <span class="n">last_cr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">column</span>

</code></pre></div></div>

<p>   通常，计算列的信息是为了指示上下文的错误位置，所以只在必要时有用。</p>

<h4 id="忽略字符">忽略字符</h4>

<p>   <code class="language-plaintext highlighter-rouge">t_ignore</code>规则比较特殊，是<code class="language-plaintext highlighter-rouge">lex.py</code>所保留用来忽略字符的，通常用来跳过空白或者不需要的字符。虽然可以通过定义像<code class="language-plaintext highlighter-rouge">t_newline()</code>这样的规则来完成相同的事情，不过使用<code class="language-plaintext highlighter-rouge">t_ignore</code>能够提供较好的词法分析性能，因为相比普通的正则式，它被特殊化处理了。</p>

<h4 id="字面字符">字面字符</h4>

<p>   字面字符可以通过在词法模块中定义一个literals变量，例如：</p>

<p><code class="language-plaintext highlighter-rouge">literals = [ '+','-','*','/' ]</code></p>

<p>或者：</p>

<p><code class="language-plaintext highlighter-rouge">literals = "+-*/"</code></p>

<p>   字面字符是指单个字符，表示把字符本身作为标记，标记的type和value都是字符本身。不过，字面字符是在其他正则式之后被检查的，因此如果有规则是以这些字符开头的，那么这些规则的优先级较高。</p>

<h4 id="错误处理">错误处理</h4>

<p>   最后，在词法分析中遇到非法字符时，<code class="language-plaintext highlighter-rouge">t_error()</code>用来处理这类错误。这种情况下，<code class="language-plaintext highlighter-rouge">t.value</code>包含了余下还未被处理的输入字串，在之前的例子中，错误处理方法是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Error handling rule
</span><span class="k">def</span> <span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"Illegal character '%s'"</span> <span class="o">%</span> <span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">这个例子中</span><span class="err">，</span><span class="n">我们只是简单的输出不合法的字符</span><span class="err">，</span><span class="n">并且通过调用</span><span class="sb">`t.lexer.skip(1)`</span><span class="n">跳过一个字符</span><span class="err">。</span>

<span class="c1">#### 构建使用lexer
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">函数</span><span class="sb">`lex.lex()`</span><span class="n">使用Python的反射机制读取调用上下文中的正则表达式</span><span class="err">，</span><span class="n">来创建</span><span class="sb">`lexer`</span><span class="err">。</span><span class="sb">`lexer`</span><span class="n">一旦创建好</span><span class="err">，</span><span class="n">有两个方法可以用来控制</span><span class="sb">`lexer`</span><span class="n">对象</span><span class="err">：</span>

<span class="o">*</span> <span class="sb">`lexer.input(data)`</span> <span class="n">重置</span><span class="sb">`lexer`</span><span class="n">和输入字串</span>
<span class="o">*</span> <span class="sb">`lexer.token()`</span> <span class="n">返回下一个</span><span class="sb">`LexToken`</span><span class="n">类型的标记实例</span><span class="err">，</span><span class="n">如果进行到输入字串的尾部时将返回</span><span class="sb">`None`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">推荐直接在</span><span class="sb">`lex()`</span><span class="n">函数返回的</span><span class="sb">`lexer`</span><span class="n">对象上调用上述接口</span><span class="err">，</span><span class="n">尽管也可以向下面这样用模块级别的</span><span class="sb">`lex.input()`</span><span class="n">和</span><span class="sb">`lex.token()`</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="n">lex</span><span class="p">.</span><span class="n">lex</span><span class="p">()</span>
<span class="n">lex</span><span class="p">.</span><span class="nb">input</span><span class="p">(</span><span class="n">sometext</span><span class="p">)</span>
<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">lex</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tok</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">print</span> <span class="n">tok</span>
    <span class="sb">``</span><span class="err">`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">在这个例子中</span><span class="err">，</span><span class="sb">`lex.input()`</span><span class="n">和</span><span class="sb">`lex.token()`</span><span class="n">是模块级别的方法</span><span class="err">，</span><span class="n">在lex模块中</span><span class="err">，</span><span class="sb">`input()`</span><span class="n">和</span><span class="sb">`token()`</span><span class="n">方法绑定到最新创建的</span><span class="sb">`lexer`</span><span class="n">对象的对应方法上</span><span class="err">。</span><span class="n">最好不要这样用</span><span class="err">，</span><span class="n">因为这种接口可能不知道在什么时候就失效</span><span class="err">。</span>

<span class="c1">#### `@TOKEN`装饰
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">在一些应用中</span><span class="err">，</span><span class="n">你可能需要定义一系列辅助的记号来构建复杂的正则表达式</span><span class="err">，</span><span class="n">例如</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="n">digit</span>            <span class="o">=</span> <span class="s">r'([0-9])'</span>
<span class="n">nondigit</span>         <span class="o">=</span> <span class="s">r'([_A-Za-z])'</span>
<span class="n">identifier</span>       <span class="o">=</span> <span class="s">r'('</span> <span class="o">+</span> <span class="n">nondigit</span> <span class="o">+</span> <span class="s">r'('</span> <span class="o">+</span> <span class="n">digit</span> <span class="o">+</span> <span class="s">r'|'</span> <span class="o">+</span> <span class="n">nondigit</span> <span class="o">+</span> <span class="s">r')*)'</span>

<span class="k">def</span> <span class="nf">t_ID</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="c1"># want docstring to be identifier above. ?????
</span>    <span class="p">...</span>
    <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">在这个例子中</span><span class="err">，</span><span class="n">我们希望</span><span class="sb">`ID`</span><span class="n">的规则引用上面的已有的变量</span><span class="err">。</span><span class="n">然而</span><span class="err">，</span><span class="n">使用文档字符串无法做到</span><span class="err">，</span><span class="n">为了解决这个问题</span><span class="err">，</span><span class="n">你可以使用</span><span class="sb">`@TOKEN`</span><span class="n">装饰器</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="kn">from</span> <span class="nn">ply.lex</span> <span class="kn">import</span> <span class="n">TOKEN</span>

<span class="o">@</span><span class="n">TOKEN</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">t_ID</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="p">...</span>

</code></pre></div></div>
<p>   装饰器可以将<code class="language-plaintext highlighter-rouge">identifier</code>关联到<code class="language-plaintext highlighter-rouge">t_ID()</code>的文档字符串上以使<code class="language-plaintext highlighter-rouge">lex.py</code>正常工作，一种等价的做法是直接给文档字符串赋值：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">t_ID</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="p">...</span>

<span class="n">t_ID</span><span class="p">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">identifier</span>
</code></pre></div></div>

<h4 id="调试">调试</h4>

<p>   如果想要调试，可以使<code class="language-plaintext highlighter-rouge">lex()</code>运行在调试模式：</p>

<p><code class="language-plaintext highlighter-rouge">lexer = lex.lex(debug=1)</code></p>

<p>   这将打出一些调试信息，包括添加的规则、最终的正则表达式和词法分析过程中得到的标记。</p>

<p>   除此之外，<code class="language-plaintext highlighter-rouge">lex.py</code>有一个简单的主函数，不但支持对命令行参数输入的字串进行扫描，还支持命令行参数指定的文件名：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
     <span class="n">lex</span><span class="p">.</span><span class="n">runmain</span><span class="p">()</span>
     <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">想要了解高级调试的详情</span><span class="err">，</span><span class="n">请移步至最后的高级调试部分</span><span class="err">。</span>

<span class="c1">####  其他方式定义词法规则
</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">上面的例子</span><span class="err">，</span><span class="n">词法分析器都是在单个的Python模块中指定的</span><span class="err">。</span><span class="n">如果你想将标记的规则放到不同的模块</span><span class="err">，</span><span class="n">使用</span><span class="sb">`module`</span><span class="n">关键字参数</span><span class="err">。</span><span class="n">例如</span><span class="err">，</span><span class="n">你可能有一个专有的模块</span><span class="err">，</span><span class="n">包含了标记的规则</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="c1"># module: tokrules.py
# This module just contains the lexing rules
</span>
<span class="c1"># List of token names.   This is always required
</span><span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span>
   <span class="s">'NUMBER'</span><span class="p">,</span>
   <span class="s">'PLUS'</span><span class="p">,</span>
   <span class="s">'MINUS'</span><span class="p">,</span>
   <span class="s">'TIMES'</span><span class="p">,</span>
   <span class="s">'DIVIDE'</span><span class="p">,</span>
   <span class="s">'LPAREN'</span><span class="p">,</span>
   <span class="s">'RPAREN'</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Regular expression rules for simple tokens
</span><span class="n">t_PLUS</span>    <span class="o">=</span> <span class="s">r'\+'</span>
<span class="n">t_MINUS</span>   <span class="o">=</span> <span class="s">r'-'</span>
<span class="n">t_TIMES</span>   <span class="o">=</span> <span class="s">r'\*'</span>
<span class="n">t_DIVIDE</span>  <span class="o">=</span> <span class="s">r'/'</span>
<span class="n">t_LPAREN</span>  <span class="o">=</span> <span class="s">r'\('</span>
<span class="n">t_RPAREN</span>  <span class="o">=</span> <span class="s">r'\)'</span>

<span class="c1"># A regular expression rule with some action code
</span><span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\d+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Define a rule so we can track line numbers
</span><span class="k">def</span> <span class="nf">t_newline</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\n+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># A string containing ignored characters (spaces and tabs)
</span><span class="n">t_ignore</span>  <span class="o">=</span> <span class="s">' </span><span class="se">\t</span><span class="s">'</span>

<span class="c1"># Error handling rule
</span><span class="k">def</span> <span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"Illegal character '%s'"</span> <span class="o">%</span> <span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="sb">``</span><span class="err">`</span>
<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">现在</span><span class="err">，</span><span class="n">如果你想要从不同的模块中构建分析器</span><span class="err">，</span><span class="n">应该这样</span><span class="err">（</span><span class="n">在交互模式下</span><span class="err">）：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">tokrules</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="p">.</span><span class="n">lex</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">tokrules</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span><span class="p">.</span><span class="nb">input</span><span class="p">(</span><span class="s">"3 + 4"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
<span class="n">LexToken</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
<span class="n">LexToken</span><span class="p">(</span><span class="n">PLUS</span><span class="p">,</span><span class="s">'+'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
<span class="n">LexToken</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
<span class="bp">None</span>
</code></pre></div></div>

<p>   <code class="language-plaintext highlighter-rouge">module</code>选项也可以指定类型的实例，例如：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">ply.lex</span> <span class="k">as</span> <span class="n">lex</span>

<span class="k">class</span> <span class="nc">MyLexer</span><span class="p">:</span>
    <span class="c1"># List of token names.   This is always required
</span>    <span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span>
       <span class="s">'NUMBER'</span><span class="p">,</span>
       <span class="s">'PLUS'</span><span class="p">,</span>
       <span class="s">'MINUS'</span><span class="p">,</span>
       <span class="s">'TIMES'</span><span class="p">,</span>
       <span class="s">'DIVIDE'</span><span class="p">,</span>
       <span class="s">'LPAREN'</span><span class="p">,</span>
       <span class="s">'RPAREN'</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Regular expression rules for simple tokens
</span>    <span class="n">t_PLUS</span>    <span class="o">=</span> <span class="s">r'\+'</span>
    <span class="n">t_MINUS</span>   <span class="o">=</span> <span class="s">r'-'</span>
    <span class="n">t_TIMES</span>   <span class="o">=</span> <span class="s">r'\*'</span>
    <span class="n">t_DIVIDE</span>  <span class="o">=</span> <span class="s">r'/'</span>
    <span class="n">t_LPAREN</span>  <span class="o">=</span> <span class="s">r'\('</span>
    <span class="n">t_RPAREN</span>  <span class="o">=</span> <span class="s">r'\)'</span>

    <span class="c1"># A regular expression rule with some action code
</span>    <span class="c1"># Note addition of self parameter since we're in a class
</span>    <span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="s">r'\d+'</span>
        <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="c1"># Define a rule so we can track line numbers
</span>    <span class="k">def</span> <span class="nf">t_newline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="s">r'\n+'</span>
        <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># A string containing ignored characters (spaces and tabs)
</span>    <span class="n">t_ignore</span>  <span class="o">=</span> <span class="s">' </span><span class="se">\t</span><span class="s">'</span>

    <span class="c1"># Error handling rule
</span>    <span class="k">def</span> <span class="nf">t_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"Illegal character '%s'"</span> <span class="o">%</span> <span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Build the lexer
</span>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="p">.</span><span class="n">lex</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Test it output
</span>    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="nb">input</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
             <span class="n">tok</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">.</span><span class="n">token</span><span class="p">()</span>
             <span class="k">if</span> <span class="ow">not</span> <span class="n">tok</span><span class="p">:</span> <span class="k">break</span>
             <span class="k">print</span> <span class="n">tok</span>

<span class="c1"># Build the lexer and try it out
</span><span class="n">m</span> <span class="o">=</span> <span class="n">MyLexer</span><span class="p">()</span>
<span class="n">m</span><span class="p">.</span><span class="n">build</span><span class="p">()</span>           <span class="c1"># Build the lexer
</span><span class="n">m</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="s">"3 + 4"</span><span class="p">)</span>     <span class="c1"># Test it
</span>
</code></pre></div></div>

<h4 id="额外状态维护">额外状态维护</h4>

<p>   在你的词法分析器中，你可能想要维护一些状态。这可能包括模式设置，符号表和其他细节。例如，假设你想要跟踪NUMBER标记的出现个数。</p>

<p>   一种方法是维护一个全局变量：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">num_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\d+'</span>
    <span class="k">global</span> <span class="n">num_count</span>
    <span class="n">num_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>
    <span class="sb">``</span><span class="err">`</span>

<span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ensp</span><span class="p">;</span><span class="n">除此之外</span><span class="err">，</span><span class="n">还可以还可以记录信息到lexer对象内部</span><span class="err">。</span><span class="n">可以通过当前标记的lexer属性访问</span><span class="err">：</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="k">def</span> <span class="nf">t_NUMBER</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="s">r'\d+'</span>
    <span class="n">t</span><span class="p">.</span><span class="n">lexer</span><span class="p">.</span><span class="n">num_count</span> <span class="o">+=</span> <span class="mi">1</span>     <span class="c1"># Note use of lexer attribute
</span>    <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>    
    <span class="k">return</span> <span class="n">t</span>

<span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="p">.</span><span class="n">lex</span><span class="p">()</span>
<span class="n">lexer</span><span class="p">.</span><span class="n">num_count</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1"># Set the initial count
</span></code></pre></div></div>

<p>   还可以自定义你的lexer类型：</p>

<p>```python
class MyLexer:
    …
    def t_NUMBER(self,t):
        r’\d+’
        self.num_count += 1
        t.value = int(t.value)
        return t</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def build(self, **kwargs):
    self.lexer = lex.lex(object=self,**kwargs)

def __init__(self):
    self.num_count = 0
    ```
</code></pre></div></div>

<h2 id="参考链接">参考链接</h2>
<ul>
  <li><a href="http://www.dabeaz.com/ply/ply.html">PLY (Python Lex-Yacc)</a></li>
</ul>
